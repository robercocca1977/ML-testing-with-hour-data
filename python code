# === OPTIMIZED BACKTEST WITH VOLATILITY-AWARE LOGIC ===

import os, glob, gc, warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import SelectKBest, f_classif
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import log_loss, roc_auc_score
from xgboost import XGBClassifier

warnings.filterwarnings("ignore")
gc.enable()
np.random.seed(42)

# === CONFIGURATION ===
DATA_PATH = os.path.expanduser("~/Downloads/sp500_top100_data")
INITIAL_CASH = 9000
REBALANCE_DAYS = 5
TRAIN_WINDOW = 150
MIN_ROWS = TRAIN_WINDOW + REBALANCE_DAYS
PLOT = True
daily_trade_log = []

# === PURGED KFOLD ===
class PurgedKFold:
    def __init__(self, n_splits=3, purge_gap=5):
        self.kf = StratifiedKFold(n_splits=n_splits)
        self.purge_gap = purge_gap
    def split(self, X, y):
        idx = np.arange(len(X))
        for train, test in self.kf.split(X, y):
            test_start, test_end = test[0], test[-1]
            mask = (idx < test_start - self.purge_gap) | (idx > test_end + self.purge_gap)
            yield idx[mask], test

# === FEATURE ENGINEERING ===
def compute_rsi(series, window):
    delta = series.diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.rolling(window).mean()
    avg_loss = loss.rolling(window).mean()
    rs = avg_gain / (avg_loss + 1e-8)
    return 100 - (100 / (1 + rs))

def add_features(df):
    df['log_ret'] = np.log(df['close'] / df['close'].shift(1))
    df['momentum_5'] = df['close'].pct_change(5)
    df['volatility_5'] = df['log_ret'].rolling(5).std() * np.sqrt(252)
    df['rsi'] = compute_rsi(df['close'], 14)
    df['ma_20'] = df['close'].rolling(20).mean()
    df['ma_50'] = df['close'].rolling(50).mean()
    df['ma_cross'] = (df['ma_20'] > df['ma_50']).astype(int)
    df['volume_z'] = (df['volume'] - df['volume'].rolling(20).mean()) / df['volume'].rolling(20).std()
    df['future_ret'] = np.log(df['close'].shift(-5) / df['close'])
    df['label'] = (df['future_ret'] > 0).astype(int)
    return df.dropna()

# === MODEL ===
def build_model():
    return Pipeline([
        ('scaler', RobustScaler()),
        ('select', SelectKBest(f_classif, k=8)),
        ('clf', XGBClassifier(
            use_label_encoder=False,
            eval_metric='logloss',
            tree_method='hist',
            random_state=42,
            n_estimators=100,
            max_depth=3,
            learning_rate=0.05,
            subsample=0.7,
            colsample_bytree=0.7
        ))
    ])

def train_predict(X, y, dates, symbol):
    if len(X) < TRAIN_WINDOW:
        return pd.Series(index=X.index, dtype=float)
    preds = pd.Series(index=X.index, dtype=float)
    for i in range(TRAIN_WINDOW, len(X) - REBALANCE_DAYS, REBALANCE_DAYS):
        X_train = X.iloc[i - TRAIN_WINDOW:i]
        y_train = y.iloc[i - TRAIN_WINDOW:i]
        X_test = X.iloc[i:i + REBALANCE_DAYS]
        date_test = dates[i:i + REBALANCE_DAYS]
        if X_train.isnull().any().any() or X_test.isnull().any().any():
            continue
        try:
            model = build_model()
            model.fit(X_train, y_train)
            proba = model.predict_proba(X_test)[:, 1]
            preds.iloc[i:i + REBALANCE_DAYS] = proba
            for j in range(len(proba)):
                daily_trade_log.append({
                    "Date": date_test[j],
                    "Symbol": symbol,
                    "Prob": proba[j],
                    "Weight": proba[j] * 0.2,
                    "TransactionCost": 1.0
                })
        except Exception:
            continue
    return preds

# === PERFORMANCE PLOTTING ===
def plot_performance(df_all):
    import matplotlib.pyplot as plt

    trade_df = pd.DataFrame(daily_trade_log)

    if not trade_df.empty:
        total_trades = len(trade_df)
        winning_trades = trade_df[trade_df['PnL'] > 0]
        losing_trades = trade_df[trade_df['PnL'] <= 0]
        win_rate = len(winning_trades) / total_trades * 100 if total_trades else 0
        avg_win = winning_trades['PnL'].mean() if not winning_trades.empty else 0
        avg_loss = losing_trades['PnL'].mean() if not losing_trades.empty else 0
        total_cost = trade_df['TotalCost'].sum() if 'TotalCost' in trade_df else 0

        print("\nüìä Strategy Performance Summary")
        print("------------------------------")
        print(f"Total Trades           : {total_trades}")
        print(f"Winning Trades         : {len(winning_trades)}")
        print(f"Losing Trades          : {len(losing_trades)}")
        print(f"Win Rate (%)           : {win_rate:.2f}%")
        print(f"Avg Win per Trade      : ${avg_win:.2f}")
        print(f"Avg Loss per Trade     : ${avg_loss:.2f}")
        print(f"Total Transaction Cost : ${total_cost:,.2f}")
        print(f"Final Equity           : ${df_all['Equity'].iloc[-1]:,.2f}")

    if not PLOT or df_all.empty:
        return

    df_all = df_all.copy()
    df_all['DailyReturn'] = df_all['Equity'].pct_change().fillna(0)
    df_all['Cumulative'] = (1 + df_all['DailyReturn']).cumprod()
    df_all['Drawdown'] = df_all['Cumulative'] / df_all['Cumulative'].cummax() - 1
    df_all['LogEquity'] = np.log(df_all['Equity'].replace(0, np.nan)).fillna(method='bfill')

    fig, axes = plt.subplots(10, 3, figsize=(24, 36))
    axes = axes.flatten()

    plots = [
        ('Equity', 'Equity Curve'),
        ('Cumulative', 'Cumulative Return'),
        ('Drawdown', 'Drawdown Curve'),
        ('DailyReturn', 'Daily Returns'),
        ('LogEquity', 'Log Equity Curve'),
    ]

    for i, (col, title) in enumerate(plots):
        axes[i].plot(df_all[col], label=title)
        axes[i].set_title(title)
        axes[i].grid(True)

    axes[5].hist(df_all['DailyReturn'].dropna(), bins=50)
    axes[5].set_title('Histogram of Daily Returns')

    axes[6].plot(df_all['DailyReturn'].rolling(20).std(), label='Rolling Volatility')
    axes[6].set_title('Rolling Volatility')

    roll = df_all['DailyReturn'].rolling(20)
    sharpe = (roll.mean() / roll.std()).fillna(0)
    axes[7].plot(sharpe, label='Rolling Sharpe')
    axes[7].set_title('Rolling Sharpe Ratio')

    monthly = df_all['DailyReturn'].resample('M').apply(lambda x: (1 + x).prod() - 1)
    axes[8].bar(monthly.index, monthly.values)
    axes[8].set_title('Monthly Returns')

    for ax in axes[9:]:
        ax.axis('off')

    plt.tight_layout()
    plt.show()

    df_all.to_csv("strategy_equity_detailed.csv")
    trade_df.to_csv("trade_log_day_by_day.csv", index=False)

# === MAIN FUNCTION ===
def main():
    data_files = glob.glob(os.path.join(DATA_PATH, "*.csv"))
    all_equities = []

    for file in data_files:
        try:
            symbol = os.path.basename(file).split("_")[0].replace(".csv", "")
            df = pd.read_csv(file)
            df.columns = df.columns.str.strip().str.lower()
            if 'date' not in df.columns: continue
            df['date'] = pd.to_datetime(df['date'], errors='coerce')
            df = df.dropna(subset=['date']).set_index('date')
            needed = ['open', 'high', 'low', 'close', 'volume']
            if not all(col in df.columns for col in needed): continue
            df = add_features(df[needed])
            if len(df) < MIN_ROWS: continue

            X = df[['momentum_5', 'volatility_5', 'rsi', 'log_ret', 'ma_cross', 'ma_20', 'ma_50', 'volume_z']]
            y = df['label']
            pred = train_predict(X, y, df.index, symbol)
            capital = INITIAL_CASH
            equity = []
            peak = capital

            for i in range(len(pred)):
                if not np.isnan(pred.iloc[i]):
                    price = df['close'].iloc[i]
                    prob = pred.iloc[i]
                    volatility = df['volatility_5'].iloc[i]
                    volume = df['volume'].iloc[i]
                    future_ret = df['future_ret'].iloc[i]

                    var_1d = 2.33 * volatility
                    if var_1d > 0.05:
                        equity.append(capital)
                        continue

                    drawdown = (peak - capital) / peak
                    if drawdown > 0.15:
                        equity.append(capital)
                        continue

                    weight = (prob * 0.2) / (1 + volatility)
                    size = (capital * weight) / price if price > 0 else 0
                    spread_cost = price * 0.001 * size
                    slip_cost = 0.0001 * volatility * volume
                    volume_cost = max(1.0, 0.0005 * volume)
                    total_cost = spread_cost + slip_cost + volume_cost

                    pnl = capital * weight * future_ret
                    capital += pnl - total_cost
                    peak = max(peak, capital)

                    daily_trade_log.append({
                        "Date": df.index[i],
                        "Symbol": symbol,
                        "Price": price,
                        "Prob": prob,
                        "Weight": weight,
                        "Volatility": volatility,
                        "VaR_1D": var_1d,
                        "Drawdown": drawdown,
                        "Volume": volume,
                        "SpreadCost": spread_cost,
                        "SlippageCost": slip_cost,
                        "VolumeCost": volume_cost,
                        "TotalCost": total_cost,
                        "PnL": pnl,
                        "Capital": capital
                    })
                equity.append(capital)

            equity_series = pd.Series(equity, index=df.index, name=symbol)
            all_equities.append(equity_series)
            print(f"‚úÖ {symbol} backtest complete")
        except Exception as e:
            print(f"‚ùå Error processing {file}: {e}")
            continue
        gc.collect()

    if all_equities:
        df_total = pd.concat(all_equities, axis=1).mean(axis=1).to_frame(name='Equity')
        plot_performance(df_total)
        print(f"\nüéØ Final Portfolio Value: ${df_total['Equity'].iloc[-1]:,.2f}")
    else:
        print("‚ùå No assets passed filters")

if __name__ == '__main__':
    main()
